# 堆

## 简介

堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于（或小于等于）其父节点的键值

每个节点键值都大于等于其父节点的键值的堆叫做 **小根堆**，否则叫做 **大根堆**。`STL` 中的 `priority_queue` 就是一个 **大根堆**。

（小根）堆支持的主要操作有：

- 插入一个数
- 查询最小值
- 删除最小值
- 合并两个堆
- 减小一个元素的值

一些功能强大的堆（**可并堆**）还可以 （高效地）支持 `merge` 等操作

> 关于堆的实现，一般使用一个序列 *h* 模拟堆，其中
>
> - **$h_{i}$ 的两个子节点分别为 $h_{2i}$ 和 $h_{2i+1}$** 
> - **$h_1$ 是根节点** 

### 堆的分类

|          操作\数据结构           |                            配对堆                            |   二叉堆    |   左偏树    |   二项堆    | 斐波那契堆  |
| :------------------------------: | :----------------------------------------------------------: | :---------: | :---------: | :---------: | :---------: |
|          插入（insert）          |                            $O(1)$                            | $O(log\ n)$ | $O(log\ n)$ |   $O(1)$    |   $O(1)$    |
|       查询最小值(find-min)       |                            $O(1)$                            |   $O(1)$    |   $O(1)$    | $O(log\ n)$ |   $O(1)$    |
|     删除最小值（delete-min）     |                         $O(log\ n)$                          | $O(log\ n)$ | $O(log\ n)$ | $O(log\ n)$ | $O(log\ n)$ |
|          合并（merge）           |                            $O(1)$                            |   $O(n)$    | $O(log\ n)$ | $O(log\ n)$ |   $O(1)$    |
| 减小一个元素的值（decrease-key） | $O(log\ n)$(下界$\Omega(log\ log\ n)$)，(下界$O(2^{2\sqrt{log\ log\ n}})$) | $O(log\ n)$ | $O(log\ n)$ | $O(log\ n)$ |   $O(1)$    |
|         是否支持可持久化         |                              ×                               |      √      |      √      |      √      |      ×      |



==习惯上，当不加限定的提到堆时，一般情况指的是 **二叉堆**==

---

## 二叉堆

### 结构

二叉堆是一棵完全二叉树，每个节点中有一个元素

以大根堆为例，树根存的元素就是最大值，小根堆同理

### 插入操作

插入操作需要保证插入后的堆也是一颗完全二叉树

- 在最下一层最右边的叶子节点处插入，若最后一层已满，就新增加一层
- **向上调整**：若插入的节点的权值大于父节点的权值，就交换，重复此过程知道不满足或者到达根
- 向上调整的时间复杂度是 $O(log\ n)$

### 删除操作

删除操作指的是 **删除堆中最大元素，也就是根节点**。

- 将根节点和最后一个节点直接交换
- 直接删掉（在最后一个节点处）的根节点
- 对于交换后的根节点进行**向下调整**：在该节点的儿子中，寻找一个最大的，于该节点交换，重复此过程知道底层
- 向下调整的时间复杂度是 $O(log\ n)$

### 减小某个节点的权值

直接修改后，向上调整一次即可，时间复杂度为 $O(log\ n)$

### 实现

关于堆的操作主要依赖于两个核心操作：向上调整和向下调整

**考虑使用一个序列 *h* 来表示堆，其中 **

- **$h_{i}$ 的两个子节点分别为 $h_{2i}$ 和 $h_{2i+1}$** 
- **$h_1$ 是根节点** 

````cpp
// 向上调整
void up(int x) {
    while (x > 1 && h[x] > h[x / 2]) {
        swap(h[x], h[x / 2]);
    }
}

// 向下调整
void down(int x) {
    while (x * 2 <= n) {
        t = x * 2;
        if (t + 1 <= n && h[t + 1] > h[t]) 
            t++;
        if (h[t] <= h[x]) 
            break;
        swap(h[x], h[t]);
        x = t;
    }
}
````

### 建堆

从一个空堆开始，插入 *n* 个元素，不在乎顺序

> 方法一：使用  **向上调整** 进行构建

从根开始，按 *BFS* 序进行

````cpp
void build_heap_1() {
    for (i = 1; i <= n; i++) 
        up(i);
}
````

对于第 *k* 层的节点，向上调整的时间复杂度为 $O(k)$ 而不是 $O(log\ n)$

总复杂度为
$$
log\ 1+log\ 2+\cdots+log\ n = \Theta(n\log n) 
$$

> 方法二：使用 **向下调整** 进行构建

从叶子开始，逐个向下调整

```cpp
void build_heap_2() {
    for (i = n; i >= 1; i--) down(i);
}
```

可以理解为，每次 *合并* 两个已经调整好的堆

向下调整的时间复杂度为 $O(\log n-k)$，注意到叶节点无需调整，因此可以从序列约 $\frac{n}{2}$ 的位置开始调整，可减少部分常数但不影响复杂度

