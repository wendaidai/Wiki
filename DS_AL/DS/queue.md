# 队列
队列是先入先出的线性数据结构，为 *FIFO* 表
## 双栈模拟队列
使用两个栈 $F，s$ 模拟队列，$F$ 为队尾的栈，$S$ 为队首的栈，支持 `push` 和 `pop` 操作
- `push`：将元素插入到 $F$ 中
- `pop`：若 $S$ 非空，则令 $S$ 弹栈；否则将 $F$ 的元素倒过来压到 $S$ 中（首位颠倒），之后再让 $S$ 弹栈

该模拟每个元素只会进入/转移/弹出一次，均摊复杂度为 $O(1)$

## C++
`c++` 中的 `STL` 提供了容器 `std:queue` ，使用前引入头文件 `<queue>`.
常用操作：
- 访问元素：
  - `front()`：返回队首元素
  - `back()`：返回队尾元素
- 修改：
  - `push()`：将传入的参数插入队尾
  - `pop()`：弹出队首元素
- 容量：
  - `empty()`：判断队列是否为空
  - `size()`：返回队列元素数量

## Python
`Python` 中由 `collections.deque` 提供双端队列
```python
from collections import deque

queue = deque([1,2,3,4,5])

# append 在队尾插入元素
queue.append(6)
# queue
# deque([1, 2, 3, 4, 5, 6])

# appendleft 在队首插入元素
queue.appendleft(0)
# queue
# deque([0, 1, 2, 3, 4, 5, 6])
```

## 循环队列
若使用数组模拟队列，则会出现一个问题：随着时间的推移，整个队列会向数组尾部移动，一旦队列到达数组最末端，即使数组前端还有空闲空间，再进行入队操作也会导致溢出（这种现象称为“假溢出”）

可采用循环的方式解决假溢出的问题，即将数组下标为 0 的位置看做是最后一个位置的后继。（数组下标为 $x$ 的元素，它的后继为 $(x + 1) \% SIZE）$。这样就形成了循环队列。